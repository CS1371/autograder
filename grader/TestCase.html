
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>TestCase: A single test for a homework submission</title><meta name="generator" content="MATLAB 9.3"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2018-03-16"><meta name="DC.source" content="TestCase.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>TestCase: A single test for a homework submission</h1><!--introduction--><p>This class defines a complete test case for a specific problem</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Fields</a></li><li><a href="#2">Methods</a></li><li><a href="#3">Remarks</a></li><li><a href="#4">Constructor</a></li><li><a href="#5">Remarks</a></li><li><a href="#6">Exceptions</a></li><li><a href="#7">Unit Tests</a></li></ul></div><h2 id="1">Fields</h2><div><ul><li><tt>call</tt>: The complete function call (i.e., <tt>[out1, out2] = myFunction(in1, in2);</tt>)</li></ul></div><div><ul><li><tt>initializer</tt>: The complete function call for a function to be run immediately before testing the student's code</li></ul></div><div><ul><li><tt>points</tt>: The points possible for this specific test case</li></ul></div><div><ul><li><tt>path</tt>: The fully qualified path to the solution code directory</li></ul></div><div><ul><li><tt>supportingFiles</tt>: A string array of complete file paths that will need to be copied to the student's directory</li></ul></div><div><ul><li><tt>loadFiles</tt>: A string array of complete file paths of MAT files to load</li></ul></div><div><ul><li><tt>banned</tt>: A string array of names of banned functions for this problem</li></ul></div><div><ul><li><tt>outputs</tt>: A structure where the field name is the name of the output, and the field value is the value of the output</li></ul></div><div><ul><li><tt>files</tt>: A <tt>File</tt> array that represents all the files produced as outputs</li></ul></div><div><ul><li><tt>plots</tt>: A <tt>Plot</tt> array that represents the plots generated</li></ul></div><h2 id="2">Methods</h2><div><ul><li><tt>TestCase(struct info, string path)</tt></li></ul></div><h2 id="3">Remarks</h2><p>The <tt>TestCase</tt> class defines all the necessary settings and conditions to run a single test of a student's function. The <tt>TestCase</tt> class stores the instructions for running the test case, and includes the solution's outputs for comparison.</p><p>The input arguments referenced in <tt>call</tt> should either be defined in <tt>loadFiles</tt> (the MAT files to be loaded), or in the <tt>initializer</tt>:</p><p>The <tt>initializer</tt> is useful if a variable's value cannot be determined until right before the function call. If <tt>initializer</tt> has outputs that will be used as inputs when calling the student's function, the names of the outputs must match the expected input names in <tt>call</tt> exactly. Such inputs that are generated at runtime don't need to appear in the MAT files, and should be overwritten if they do exist.</p><p>For example, suppose you wanted to populate input <tt>fid</tt> with a file handle. In that case, your <tt>initializer</tt> would look like:</p><pre class="language-matlab">[fid] = fopen(<span class="string">'myInput.txt'</span>);
</pre><p>Now suppose <tt>fid</tt> is now 3. This will pass in 3 as an input to the function.</p><p>The initializer function can also be used to load a MAT-file, from the <tt>supportingFiles</tt> that are copied into the student's directory. Again, the variable names inside the MAT-file should match the input names in <tt>call</tt>.</p><pre class="codeinput"><span class="keyword">classdef</span> TestCase &lt; handle
    <span class="keyword">properties</span> (Access = public)
        call;
        initializer;
        points;
        supportingFiles;
        loadFiles;
        banned;
        path;
        outputs;
        files;
        plots;
    <span class="keyword">end</span>
    <span class="keyword">methods</span>
</pre><h2 id="4">Constructor</h2><p>The <tt>TestCase</tt> constructor creates a new <tt>TestCase</tt> from a structure representing parsed JSON.</p><p>T = TestCase(INFO, PATH) will create a new <tt>TestCase</tt> with all the fields filled with values from the solution. INFO should be a structure with the fields <tt>call</tt>, <tt>initializer</tt>, <tt>points</tt>, <tt>supportingFiles</tt>, <tt>banned</tt>. PATH is a fully qualified path to the student's directory.</p><h2 id="5">Remarks</h2><p>The format that the structure <tt>INFO</tt> should follow is shown by the JSON example below:</p><pre class="language-matlab">{
    <span class="string">"call"</span>: <span class="string">"[out1, out2] = myFun(in1, in2);"</span>,
    <span class="string">"initializer"</span>: <span class="string">""</span>,
    <span class="string">"points"</span>: 3,
    <span class="string">"supportingFiles"</span>: [
        <span class="string">"myFile.txt"</span>,
        <span class="string">"myInputImage.png"</span>,
        <span class="string">"myTestCases.mat"</span>
    ],
    <span class="string">"banned"</span>: [
        <span class="string">"fopen"</span>,
        <span class="string">"fclose"</span>,
        <span class="string">"fseek"</span>,
        <span class="string">"frewind"</span>
    ]
}
</pre><p>Note that white space does <i>not</i> matter in the input JSON.</p><p>The <tt>initializer</tt> is a special function call. <tt>initializer</tt> specifies a function that is designed to run <i>the moment before</i> the main test case is run. This is useful for defining an input that can't be known until runtime. For example, suppose you wanted an open file handle as an input. This could not be done at compile time, since many files may be open when the test case is run. There are some restrictions on <tt>initializer</tt>, however:</p><div><ul><li>It must be a <i>valid function call</i>. It cannot be just proper MATLAB code - only a single function call is allowed</li></ul></div><div><ul><li>It's outputs must be named <i>exactly the same</i> as any inputs to the function.</li></ul></div><div><ul><li>It can reference any valid function, but variable <i>inputs</i> to the <tt>initializer</tt> are not allowed.</li></ul></div><p>See above for an example of how to use the initializer. If the initializer is not found, or is left blank, then it is assumed that no initialization is required.</p><p>As for the variables in the MAT files, it's values <i>must</i> be literals. You cannot use arbitrary MATLAB code as the value. To execute arbitrary MATLAB code, see the remarks for the <tt>initializer</tt>.</p><p>The caller does <i>not</i> need to worry about "cleaning up" any open resources (such as files or figures). Since the autograder will already handle closing these resources, cleanup is the responsibility of <tt>TestCase</tt>, not the writer of the JSON.</p><p>Additionally, the name of the supporting function can be anything. But best practice is for it to be named something "guaranteed" to be unique; as such, suffixing the initializer function name with '__' is usually a good idea.</p><h2 id="6">Exceptions</h2><p>The constructor throws the <tt>AUTOGRADER:TESTCASE:CTOR:BADINFO</tt> if there are problems with the INFO structure. This exception should not be consumed, because this means the <tt>TestCase</tt> is incomplete. It also throws this error if <tt>call</tt> or <tt>initializer</tt> has a syntax error.</p><p>The constructor throws the <tt>AUTOGRADER:TESTCASE:CTOR:BADSOLUTION</tt> if the solution errors. This should never happen, as long as the solution files won't error for the given inputs. This error will also be thrown if the initializer errors when running the solution.</p><h2 id="7">Unit Tests</h2><p>Assume INFO struct that looks like the example given above.</p><pre class="language-matlab">J = <span class="string">'...'</span> <span class="comment">% Valid INFO;</span>
P = <span class="string">'...'</span> <span class="comment">% Valid path;</span>
T = TestCase(J, P);
</pre><pre class="language-matlab">T <span class="string">isa</span> <span class="string">|TestCase|</span>
T.call -&gt; <span class="string">"[out1, out2] = myFun(in1, in2);"</span>
T.initializer -&gt; [];
T.points -&gt; 3;
T.supportingFiles -&gt; [<span class="string">"myFile.txt"</span>, <span class="string">"myInputImage.png"</span>];
T.loadFiles -&gt; [<span class="string">"myTestCases.mat"</span>];
T.banned -&gt; [<span class="string">"fopen"</span>, <span class="string">"fclose"</span>, <span class="string">"fseek"</span>, <span class="string">"frewind"</span>];
T.path -&gt; <span class="string">'...'</span> <span class="comment">% Valid path</span>
</pre><p>Note that the following would be filled <i>after</i> running the solution. This is still done in the constructor. For this example, assume the function created one image file and one text file. For the purposes of documenting <tt>TestCase</tt>, we will not explore the contents of those files - that will be covered in <tt>File</tt>.</p><pre class="language-matlab">T.outputs -&gt; struct(<span class="string">'out1'</span>, 2, <span class="string">'out2'</span>, <span class="string">'Hello, World!'</span>);
T.files -&gt; File[2]
</pre><p>Now suppose the structure in <tt>J</tt> is similiar to the following JSON:</p><pre class="language-matlab">{
    <span class="string">"call"</span>: <span class="string">"[out1, out2] = myFun(in1, in2);"</span>,
    <span class="string">"initializer"</span>: <span class="string">"in2 = supportFunction__"</span>,
    <span class="string">"points"</span>: 3,
    <span class="string">"supportingFiles"</span>: [
        <span class="string">"myFile.txt"</span>,
        <span class="string">"myInputImage.png"</span>,
        <span class="string">"supportFunction__.m"</span>
        <span class="string">"myTestCases.mat"</span>
    ],
    <span class="string">"banned"</span>: [
        <span class="string">"fopen"</span>,
        <span class="string">"fclose"</span>,
        <span class="string">"fseek"</span>,
        <span class="string">"frewind"</span>
    ]
}
</pre><p>Note the <tt>initializer</tt> is set. Suppose the following is found in "supportFunction__.m":</p><pre class="language-matlab"><span class="keyword">function</span> out = supportFunction__()
    out = fopen(<span class="string">'myFile.txt'</span>, <span class="string">'r'</span>);
<span class="keyword">end</span>
</pre><p>Now we call the function:</p><pre class="language-matlab">T = TestCase(J, P);
</pre><pre class="language-matlab">T <span class="string">isa</span> <span class="string">|TestCase|</span>
T.call -&gt; <span class="string">"[out1, out2] = myFun(in1, in2);"</span>
T.initializer -&gt; <span class="string">"[in1] = supportFunction__();"</span>;
T.points -&gt; 3;
T.supportingFiles -&gt; [<span class="string">"myFile.txt"</span>, <span class="string">"myInputImage.png"</span>, <span class="string">"supportFunction__.m"</span>];
T.loadFiles -&gt; [<span class="string">"myTestCases.mat"</span>];
T.banned -&gt; [<span class="string">"fopen"</span>, <span class="string">"fclose"</span>, <span class="string">"fseek"</span>, <span class="string">"frewind"</span>];
T.path -&gt; <span class="string">'...'</span> <span class="comment">% Valid path</span>
</pre><p>The following are filled in after everything is run. Note that for this case, the in2 is calculated <i>immediately</i> before the function is run.</p><pre class="language-matlab">T.outputs -&gt; struct(<span class="string">'out1'</span>, 1, <span class="string">'out2'</span>, false);
T.files -&gt; File[2];
T.plots -&gt; Plot[1];
</pre><p>Assume J structure is empty or has missing fields:   T = TestCase(J, P);</p><pre class="language-matlab">The <span class="string">constructor</span> <span class="string">threw</span> <span class="string">exception</span>
AUTOGRADER:TESTCASE:CTOR:BADINFO
</pre><p>Assume J is valid structure, but the solution code errors.</p><p>Running the constructor:   T = TestCase(J, P);</p><pre class="language-matlab">The <span class="string">constructor</span> <span class="string">threw</span> <span class="string">exception</span>
AUTOGRADER:TESTCASE:CTOR:BADSOLUTION
</pre><pre class="codeinput">        <span class="keyword">function</span> this = TestCase(info, path)
            <span class="keyword">try</span>
                this.path = path;

                <span class="comment">% Copy values from struct to TestCase. Do one-by-one</span>
                <span class="comment">% instead of iterating in case fields are wrong/missing.</span>
                <span class="comment">% If a field is missing, exception is caught and</span>
                <span class="comment">% re-thrown as a parse error.</span>
                this.call = info.call;
                this.initializer = info.initializer;
                this.points = info.points;
                this.banned = info.banned;

                <span class="comment">% contains() errors if supportingFiles is empty</span>
                <span class="keyword">if</span> ~isempty(info.supportingFiles)
                    toLoad = contains(info.supportingFiles, <span class="string">'.mat'</span>);
                    this.loadFiles = info.supportingFiles(toLoad);
                    this.supportingFiles = info.supportingFiles(~toLoad);
                <span class="keyword">end</span>
            <span class="keyword">catch</span>
                throw(MException(<span class="string">'AUTOGRADER:TESTCASE:CTOR:BADINFO'</span>, <span class="keyword">...</span>
                    <span class="string">'Problem with INFO struct fields'</span>));
            <span class="keyword">end</span>

            <span class="comment">% Engine can throw parse exceptions for bad |call| or</span>
            <span class="comment">% |initializer|, and bad solution exception. Don't catch,</span>
            <span class="comment">% let it propagate instead</span>
            engine(this);
        <span class="keyword">end</span>
</pre><pre class="codeinput">    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2017b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% TestCase: A single test for a homework submission
%
% This class defines a complete test case for a specific problem
%
%%% Fields
%
% * |call|: The complete function call 
% (i.e., |[out1, out2] = myFunction(in1, in2);|)
%
% * |initializer|: The complete function call for a function to be run 
% immediately before testing the student's code
%
% * |points|: The points possible for this specific test case
%
% * |path|: The fully qualified path to the solution code directory
%
% * |supportingFiles|: A string array of complete file paths that will need 
% to be copied to the student's directory
%
% * |loadFiles|: A string array of complete file paths of MAT files to load
%
% * |banned|: A string array of names of banned functions for this problem
%
% * |outputs|: A structure where the field name is the name of the output, 
% and the field value is the value of the output
%
% * |files|: A |File| array that represents all the files produced as outputs
%
% * |plots|: A |Plot| array that represents the plots generated
%
%%% Methods
%
% * |TestCase(struct info, string path)|
%
%%% Remarks
%
% The |TestCase| class defines all the necessary settings and conditions to
% run a single test of a student's function. The |TestCase| class stores
% the instructions for running the test case, and includes the solution's
% outputs for comparison.
%
% The input arguments referenced in |call| should either be defined in
% |loadFiles| (the MAT files to be loaded), or in the |initializer|:
%
% The |initializer| is useful if a variable's value cannot be determined 
% until right before the function call. If |initializer| has outputs that will
% be used as inputs when calling the student's function, the names of the
% outputs must match the expected input names in |call| exactly. Such inputs
% that are generated at runtime don't need to appear in the MAT files, and
% should be overwritten if they do exist.
% 
% For example, suppose you wanted to populate input |fid| with a file handle.
% In that case, your |initializer| would look like:
%
%   [fid] = fopen('myInput.txt');
%
% Now suppose |fid| is now 3. This will pass in 3 as an input to the function.
%
% The initializer function can also be used to load a MAT-file, from the
% |supportingFiles| that are copied into the student's directory. Again, the
% variable names inside the MAT-file should match the input names in |call|.
%
classdef TestCase < handle
    properties (Access = public)
        call;
        initializer;
        points;
        supportingFiles;
        loadFiles;
        banned;
        path;
        outputs;
        files;
        plots;
    end
    methods
        %% Constructor
        %
        % The |TestCase| constructor creates a new |TestCase| from a
        % structure representing parsed JSON.
        %
        % T = TestCase(INFO, PATH) will create a new |TestCase| with all the fields 
        % filled with values from the solution. INFO should be a structure with
        % the fields |call|, |initializer|, |points|, |supportingFiles|,
        % |banned|. PATH is a fully qualified path to the
        % student's directory.
        %
        %%% Remarks
        %
        % The format that the structure |INFO| should follow
        % is shown by the JSON example below:
        %
        %   {
        %       "call": "[out1, out2] = myFun(in1, in2);",
        %       "initializer": "",
        %       "points": 3,
        %       "supportingFiles": [
        %           "myFile.txt",
        %           "myInputImage.png",
        %           "myTestCases.mat"
        %       ],
        %       "banned": [
        %           "fopen",
        %           "fclose",
        %           "fseek",
        %           "frewind"
        %       ]
        %   }
        %
        % Note that white space does _not_ matter in the input JSON.
        %
        % The |initializer| is a special function call. |initializer| specifies
        % a function that is designed to run _the moment before_ the main test 
        % case is run. This is useful for defining an input that can't be 
        % known until runtime. For example, suppose you wanted an open 
        % file handle as an input. This could not be done at compile time, 
        % since many files may be open when the test case is run. There are 
        % some restrictions on |initializer|, however:
        %
        % * It must be a _valid function call_. It cannot be just proper 
        % MATLAB code - only a single function call is allowed
        %
        % * It's outputs must be named _exactly the same_ as any inputs to 
        % the function.
        %
        % * It can reference any valid function, but variable _inputs_ 
        % to the |initializer| are not allowed.
        %
        % See above for an example of how to use the initializer. 
        % If the initializer is not found, or is left blank, then it is assumed
        % that no initialization is required.
        %
        % As for the variables in the MAT files, it's values _must_ be
        % literals. You cannot use arbitrary MATLAB code as the value. To
        % execute arbitrary MATLAB code, see the remarks for the |initializer|.
        %
        % The caller does _not_ need to worry about "cleaning up" any open 
        % resources (such as files or figures). Since the autograder will 
        % already handle closing these resources, cleanup is the responsibility
        % of |TestCase|, not the writer of the JSON.
        %
        % Additionally, the name of the supporting function can be anything. 
        % But best practice is for it to be named something "guaranteed" to be
        % unique; as such, suffixing the initializer function name with '__'
        % is usually a good idea.
        %
        %%% Exceptions
        %
        % The constructor throws the |AUTOGRADER:TESTCASE:CTOR:BADINFO| if
        % there are problems with the INFO structure. This exception should not
        % be consumed, because this means the |TestCase| is incomplete. It also
        % throws this error if |call| or |initializer| has a syntax error.
        %
        % The constructor throws the |AUTOGRADER:TESTCASE:CTOR:BADSOLUTION| if
        % the solution errors. This should never happen, as long as the 
        % solution files won't error for the given inputs. This error will also 
        % be thrown if the initializer errors when running the solution.
        %
        %%% Unit Tests
        %
        % Assume INFO struct that looks like the example given above.
        % 
        %   J = '...' % Valid INFO;
        %   P = '...' % Valid path;
        %   T = TestCase(J, P);
        %
        %   T isa |TestCase|
        %   T.call -> "[out1, out2] = myFun(in1, in2);"
        %   T.initializer -> [];
        %   T.points -> 3;
        %   T.supportingFiles -> ["myFile.txt", "myInputImage.png"];
        %   T.loadFiles -> ["myTestCases.mat"];
        %   T.banned -> ["fopen", "fclose", "fseek", "frewind"];
        %   T.path -> '...' % Valid path
        % 
        % Note that the following would be filled _after_ running the solution. 
        % This is still done in the constructor. For this example, assume the 
        % function created one image file and one text file. For the purposes 
        % of documenting |TestCase|, we will not explore the contents of 
        % those files - that will be covered in |File|.
        %
        %   T.outputs -> struct('out1', 2, 'out2', 'Hello, World!');
        %   T.files -> File[2]
        %
        % Now suppose the structure in |J| is similiar to the following JSON:
        %
        %   {
        %       "call": "[out1, out2] = myFun(in1, in2);",
        %       "initializer": "in2 = supportFunction__",
        %       "points": 3,
        %       "supportingFiles": [
        %           "myFile.txt",
        %           "myInputImage.png",
        %           "supportFunction__.m"
        %           "myTestCases.mat"
        %       ],
        %       "banned": [
        %           "fopen",
        %           "fclose",
        %           "fseek",
        %           "frewind"
        %       ]
        %   }
        %
        % Note the |initializer| is set. Suppose the following is 
        % found in "supportFunction__.m":
        %
        %   function out = supportFunction__()
        %       out = fopen('myFile.txt', 'r');
        %   end
        %
        % Now we call the function:
        %
        %   T = TestCase(J, P);
        %
        %   T isa |TestCase|
        %   T.call -> "[out1, out2] = myFun(in1, in2);"
        %   T.initializer -> "[in1] = supportFunction__();";
        %   T.points -> 3;
        %   T.supportingFiles -> ["myFile.txt", "myInputImage.png", "supportFunction__.m"];
        %   T.loadFiles -> ["myTestCases.mat"];
        %   T.banned -> ["fopen", "fclose", "fseek", "frewind"];
        %   T.path -> '...' % Valid path
        %
        % The following are filled in after everything is run. 
        % Note that for this case, the in2 is calculated _immediately_
        % before the function is run.
        %
        %   T.outputs -> struct('out1', 1, 'out2', false);
        %   T.files -> File[2];
        %   T.plots -> Plot[1];
        %
        % Assume J structure is empty or has missing fields:
        %   T = TestCase(J, P);
        %
        %   The constructor threw exception 
        %   AUTOGRADER:TESTCASE:CTOR:BADINFO
        %
        % Assume J is valid structure, but the solution code errors.
        %
        % Running the constructor:
        %   T = TestCase(J, P);
        % 
        %   The constructor threw exception
        %   AUTOGRADER:TESTCASE:CTOR:BADSOLUTION
        function this = TestCase(info, path)
            try
                this.path = path;
                
                % Copy values from struct to TestCase. Do one-by-one
                % instead of iterating in case fields are wrong/missing.
                % If a field is missing, exception is caught and
                % re-thrown as a parse error.
                this.call = info.call;
                this.initializer = info.initializer;
                this.points = info.points;
                this.banned = info.banned;
                
                % contains() errors if supportingFiles is empty
                if ~isempty(info.supportingFiles)
                    toLoad = contains(info.supportingFiles, '.mat');
                    this.loadFiles = info.supportingFiles(toLoad);
                    this.supportingFiles = info.supportingFiles(~toLoad);
                end
            catch
                throw(MException('AUTOGRADER:TESTCASE:CTOR:BADINFO', ...
                    'Problem with INFO struct fields'));
            end
            
            % Engine can throw parse exceptions for bad |call| or
            % |initializer|, and bad solution exception. Don't catch,
            % let it propagate instead
            engine(this);
        end
    end
end

##### SOURCE END #####
--></body></html>