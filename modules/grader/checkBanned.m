%% checkBanned: Check a function file for banned function usage
%
% checkBanned will read a function file to determine if it ever uses a
% banned function.
%
% [I, F] = checkBanned(N, B, P) will use function name N, cell array of
% banned function names B, and path P to determine if the function used any
% banned functions. If it did, then I will be true, and F will contain a
% comma separated string of all the banned functions. Otherwise, I will be
% false, and F will be empty.
%
% [I, F] = checkBanned(N, B, P, U) will do the same as above, except it
% will include the default banned list if U is true; otherwise, it will
% exclusively use banned list B. Defaults to true.
%
%%% Remarks
%
% checkBanned will use the mtree function to create an AST of the student's
% code. Any bugs in mtree will, therefore, propogate forward.
%
% checkBanned recursively checks the student's code, walking the call chain
% until it reaches a built-in function, or terminates. This means that if a
% built in function uses a banned function, then that won't be caught.
%
% checkBanned does static checking of the student file, which means it can
% be quite performant. However, strictly speaking, this means that
% sometimes the student can "trick" the autograder into thinking it did
% call a banned function. Specifically, suppose the coder had the
% following code:
%
%   if false
%       bannedFunction();
%   end
%
% checkBanned would still return true, because it has no way of knowing
% that the code won't actually be run.
%
% Should the student overwrite a banned function (i.e., they wrote a
% separate file called "bannlsedFunction.m"), checkBanned will not mark them
% as using a banned function, unless bannedFunction.m uses a banned
% function.
%
% Operations should be prefixed with a double __, such as __GLOBAL, and
% need to conform to the operation names in mtree
%
% See also mtree, checkRecur, engine
function [isBan, funName] = checkBanned(name, banned, path, useDefault)
    BANNED = {'addpath', ...
        'assignin', ...
        'audioplayer', ...
        'audiorecorder', ...
        'batch', ...
        'beep', ...
        'builtin', ...
        'cancel', ...
        'cd', ...
        'copyfile', ...
        'dbstack', ...
        'dbstop', ...
        'delete', ...
        'dir', ...
        'edit', ...
        'eval', ...
        'evalc', ...
        'evalin', ...
        'exit', ...
        'fetchNext', ...
        'fetchOutputs', ...
        'feval', ...
        'figure', ...
        'fileattrib', ...
        'ftp', ...
        'gcp', ...
        'get', ...
        'gunzip', ...
        'gzip', ...
        'hgsave', ...
        'input', ...
        'keyboard', ...
        'load', ...
        'ls', ...
        'matfile', ...
        'mget', ...
        'mkdir', ...
        'movefile', ...
        'open', ...
        'parfeval', ...
        'parfevalOnAll', ...
        'parpool', ...
        'path', ...
        'perl', ...
        'quit', ...
        'restoredefaultpath', ...
        'rmdir', ...
        'rmpath', ...
        'save', ...
        'saveas', ...
        'send', ...
        'set', ...
        'settings', ...
        'sound', ...
        'soundsc', ...
        'system', ...
        'system_save', ...
        'tar', ...
        'tcpip', ...
        'uifigure', ...
        'uiwait', ...
        'unix', ...
        'untar', ...
        'unzip', ...
        'urlread', ...
        'urlwrite', ...
        'wait', ...
        'web', ...
        'weboptions', ...
        'webread', ...
        'websave', ...
        'webwrite', ...
        'winopen', ...
        'workspace', ...
        'zip'};
    BANNED_OPS = {'__BANG', '__PARFOR', '__SPMD', '__GLOBAL'};
    
    if nargin < 4
        useDefault = true;
    end
    if useDefault
        banned = [banned, BANNED, BANNED_OPS];
    end
    calls = getCalls([path filesep name]);
    % calls is complete set of calls to builtin functions. If any of them
    % match up, then we have a winner!
    
    funName = calls(ismember(calls, banned));
    mask = strncmp(funName, '__', 2);
    funName(mask) = ...
        cellfun(@(s)(s(3:end)), funName(mask), 'uni', false);
    funName = strjoin(funName, ', ');
    isBan = ~isempty(funName);
end

function calls = getCalls(path, ignore)
    if nargin == 1
        ignore = {};
    end
    [fld, name, ~] = fileparts(path);
    info = mtree(path, '-file');
    calls = info.mtfind('Kind', {'CALL', 'DCALL'}).Left.stringvals;
    atCalls = info.mtfind('Kind', 'AT').Tree.mtfind('Kind', 'ID').stringvals;
    innerFunctions = info.mtfind('Kind', 'FUNCTION').Fname.stringvals;
    % any calls to inner functions should die
    calls = [calls, atCalls];
    calls(ismember(calls, [innerFunctions ignore])) = [];

    % For any calls that exist in our current directory, recursively
    % collect their builtin calls
    localFuns = dir([fld filesep '*.m']);
    localFuns = {localFuns.name};
    localFuns = cellfun(@(s)(s(1:end-2)), localFuns, 'uni', false);
    localCalls = calls(ismember(calls, localFuns));
    calls(ismember(calls, localFuns)) = [];
    for l = 1:numel(localCalls)
        calls = [calls getCalls([fld filesep localCalls{l} '.m'], [ignore {name}])]; %#ok<AGROW>
    end

    % add any operations
    OPS = {'BANG', 'PARFOR', 'SPMD', 'GLOBAL'};
    calls = [calls reshape(compose('__%s', string(info.mtfind('Kind', OPS).kinds)), 1, [])];
    calls = unique(calls);
end